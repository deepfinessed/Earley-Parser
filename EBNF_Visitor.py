from typing import Callable, Dict, List

from Tree import Node
from Rule import Rule, Token

def expect(node: Node, char: str):
    if not node.value.value == char:
        raise ValueError(f"Unexpected {node.value}, expected a {char}")

class EBNF_Visitor:
    """
    A visitor for the tree generated by EBNF_Grammar.py. It returns a grammar to be consumed by Parser.py
    """


    grammar: Dict[Token, List[Rule]]

    def __init__(self):
        self.grammar = {}

    def generate_grammar(self, node: Node[Token]) -> Dict[Token, List[Rule]]:
        self.visit_grammar(node)
        return self.grammar

    # Each grammar node holds a rule and optionally another grammar node
    # This adds its rule to the grammar
    def visit_grammar(self, node: Node[Token]):
        """
        Each grammar node holds a rule and optionally another grammar node
        This adds its rule to the grammar
        """
        if node.value.token_type != 'grammar':
            raise ValueError(f"visit_grammar on non-grammar {node.value.token_type}")

        children = node.children
        if len(children) > 2:
            raise ValueError(f"More than 3 children for grammar node {node}")
        rule_node = children[0]
        if len(children) > 1:
            grammar_node = children[1]
            self.visit_grammar(grammar_node)
        rules = self.visit_rule(rule_node)
        if not rules:
            raise ValueError("visit_rules returned no rule")
        rule, *_ = rules
        if rule.lhs in self.grammar:
            raise ValueError(f"Repeated rules are not yet allowed with rhs {rule.rhs}")
        self.grammar[rule.lhs] = rules


    # This returns the rule corresponding to this node
    def visit_rule(self, node: Node[Token]) -> List[Rule]:
        """
        Returns the rule corresponding to this node
        """
        if node.value.token_type != 'rule':
            raise ValueError(f"visit_rule on non-rule {node.value.token_type}")
        children = node.children
        if len(children) != 4:
            raise ValueError(f"Rule token with non-4 children {node.children}")
        lhs_node, equals_node, rhs_node, semicolon_node = children
        lhs = self.visit_lhs(lhs_node)
        expect(equals_node, "=")
        rhs_list = self.visit_rhs(rhs_node)
        expect(semicolon_node, ";")

        return [Rule(lhs, rhs) for rhs in rhs_list]

    def visit_lhs(self, node: Node[Token]) -> Token:
        """
        Returns the token corresponding to the left hand side
        """
        if node.value.token_type != 'lhs':
            raise ValueError(f"visit_lhs on non-lhs {node.value.token_type}")
        children = node.children
        if len(children) != 1:
            raise ValueError(f"lhs without 1 child {children}")
        lhs_node, = node.children
        return Token(lhs_node.value.value)

    def visit_rhs(self, node: Node[Token]) -> List[List[Token]]:
        """
        Returns the right hand side of a rule
        Note that that consists of all possible combinations of tokens, hence list of lists

        rhs = term
     | or;
        """
        if node.value.token_type != 'rhs':
            raise ValueError(f"visit_rhs on non-rhs {node.value.token_type}")
        children = node.children
        if len(children) != 1:
            raise ValueError(f"rhs with wrong number of children {children}")

        right_sides: Dict[str, Callable[[Node[Token]], List[List[Token]]]] = {
            "identifier" : self.visit_identifier,
            "terminal"   : self.visit_terminal,
            "optional"   : self.visit_optional,
            "repitition" : self.visit_repitition,
            "group"      : self.visit_group,
            "or"         : self.visit_or,
            "concat"     : self.visit_concat,
        }
        rhs_node, = children
        token_type = rhs_node.value.token_type
        if not token_type:
            raise ValueError(f"Invalid token without type {rhs_node.value}")
        if token_type == 'or':
            return self.visit_or(rhs_node)
        return self.visit_sequence(rhs_node)

    def visit_sequence(self, node: Node[Token]) -> List[List[Token]]:
        if node.value.token_type != 'sequence':
            raise ValueError(f"visit_term on non-term {node.value}")
        children = node.children
        if len(children) != 1:
            raise ValueError(f"visit_sequence with wrong number of children {children}")
        sequence, = node.children
        if sequence.value.token_type == 'term':
            return self.visit_term(sequence)
        return self.visit_concat(sequence)

    def visit_term(self, node: Node[Token]) -> List[List[Token]]:
        if node.value.token_type != 'term':
            raise ValueError(f"visit_term on non-term {node.value}")
        # term = optional | repitition | concat | terminal | identifier | group;
        term_types: Dict[str, Callable[[Node[Token]], List[List[Token]]]] = {
            "identifier": self.visit_identifier,
            "terminal": self.visit_terminal,
            "optional": self.visit_optional,
            "repitition": self.visit_repitition,
            "group": self.visit_group,
        }
        term, = node.children
        term_type = term.value.token_type
        if not term_type:
            raise ValueError(f"Invalid token without type {term}")
        try:
            func = term_types[term_type]
            return func(term)
        except KeyError as e:
            print(f"Invalid type {term_type} for visit_term")
            raise e

    def visit_optional(self, node: Node[Token]) -> List[List[Token]]:
        if node.value.token_type != 'optional':
            raise ValueError(f"visit_group on non-optional {node.value}")
        children = node.children
        if len(children) != 3:
            raise ValueError(f"Incorrect number of children for optional {children}")

        left_bracket, rhs_node, right_bracket = children
        expect(left_bracket, "[")
        opt_rhs = self.visit_rhs(rhs_node)
        expect(right_bracket, "]")
        opt_rhs.append([])
        return opt_rhs


    def visit_repitition(self, node: Node[Token]) -> List[List[Token]]:

        # We will implement optional repitition as follows:
        # When we see something like A -> {B}, C
        # We will say that is equivalent to:
        # A -> C  (the expression in brackets is empty)
        # A -> B_RPT C (where B_RPT represents B one or more times)
        # And then we will have to add the new rules to our grammar:
        # B_RPT -> B
        # B_RPT -> B, B_RPT

        if node.value.token_type != 'repitition':
            raise ValueError(f"visit_group on non-repitition {node.value}")
        children = node.children
        if len(children) != 3:
            raise ValueError(f"Incorrect number of children for repitition {children}")

        left_bracket, rhs_node, right_bracket = children

        expect(left_bracket, "{")
        repeat_rhs = self.visit_rhs(rhs_node)
        expect(right_bracket, "}")

        rhs_string = self.terminal_string(node)
        repeat_string = rhs_string + "_RPT"

        # Add the rule corresponding to the repitition
        rhs_token = Token(rhs_string)
        repeat_token = Token(repeat_string)
        #  B_RPT -> B
        # rhs_rpt: B_RPT -> B, B_RPT
        rhs_rpt = [rhs + [repeat_token] for rhs in repeat_rhs]
        rhs_rpt.extend(repeat_rhs)
        repeat_rule = Rule(repeat_token, [tuple(rhs) for rhs in rhs_rpt])
        # A -> C  (the expression in brackets is empty)
        # A -> B_RPT, C (where B_RPT represents B one or more times)
        return [[], [repeat_token]]

    def visit_group(self, node: Node[Token]) -> List[List[Token]]:

        # We want to do two things: Substitute the group with an appropriate token,
        # and create the rule that allows the expansion of that token.
        # For example, A -> B, (C|D); will be grouped by making an identifier of form
        # (C|D), then inserting a new rule mapping identifier
        # (C|D) -> C
        # (C|D) -> D
        if node.value.token_type != 'group':
            raise ValueError(f"visit_group on non-group {node.value}")
        children = node.children
        if len(children) != 3:
            raise ValueError(f"Incorrect number of children for group {children}")

        left_paren, rhs_node, right_paren = children

        expect(left_paren, "(")
        new_rhs = self.visit_rhs(rhs_node)
        expect(right_paren ,")")

        # Add the rules to handle the new group token
        group_string = self.terminal_string(node).replace('"','')
        group_lhs = Token(group_string)
        group_rules = [Rule(group_lhs, rhs) for rhs in new_rhs]
        self.grammar[group_lhs] = group_rules

        # And return the new token corresponding to the group
        return [[group_lhs]]

    def visit_or(self, node: Node[Token]) -> List[List[Token]]:
        # or = term , "|" , rhs;
        if node.value.token_type != 'or':
            raise ValueError(f"visit_or on non-or {node.value}")
        children = node.children
        if len(children) != 3:
            raise ValueError(f"Incorrect number of children for or {children}")
        left_nodes, bar, right_nodes = children
        left = self.visit_sequence(left_nodes)
        expect(bar, "|")
        right = self.visit_rhs(right_nodes)
        left.extend(right)
        return left

    def visit_concat(self, node: Node[Token]):
        if node.value.token_type != 'concat':
            raise ValueError(f"visit_concat on non-concat {node.value}")
        children = node.children
        if len(children) != 3:
            raise ValueError(f"Incorrect number of children for concat {children}")
        prefix_nodes, comma, suffix_nodes = children
        prefixes = self.visit_term(prefix_nodes)
        expect(comma, ",")
        suffixes = self.visit_sequence(suffix_nodes)
        concatinated_rhs = [prefix + suffix for prefix in prefixes for suffix in suffixes]
        return concatinated_rhs

    def visit_identifier(self, node: Node[Token]) -> List[List[Token]]:
        if node.value.token_type != 'identifier':
            raise ValueError(f"visit_identifier on non-identifier {node.value}")
        return [[Token(node.value.value)]]

    def visit_terminal(self, node: Node[Token]) -> List[List[Token]]:
        if node.value.token_type != 'terminal':
            raise ValueError(f"visit_terminal on non-terminal {node.value}")
        return [[Token("_TERMINAL", value=node.value.value)]]

    def terminal_string(self, node: Node):
        if node.children:
            child_strings = [self.terminal_string(child) for child in node.children]
            return ''.join(child_strings)
        return str(node.value)
